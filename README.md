# ace128-rpi
Raspberry PI Python module to support the Bourns ACE128 encoder with PCF8574 I2C backpack

Forked from [![arielnh56/ace128-rpi][1]] and upgraded to Python3

This replicates the functionality of the [Arduino ace128](https://github.com/arielnh56) repo on the RaspberryPI python platform.

![Bourns ACE-128](http://www.bourns.com/images/Products/encoders/dataprodline_sensors_controls_enc_contact.jpg)

This library provides support for the Bourns EAW - Absolute Contacting Encoder (ACE) 

Datasheet: https://www.bourns.com/pdfs/ace.pdf

This is a small 8 bit gray code rotary position sensor providing 128 unique positions. It manages this with a single encoder track with 8 contacts spaced evenly around it.  

This is a "digital knob" you can use to control your arduino project. It can
also be used in motion control systems with a limited lifespan.

This code is developed against the Arduino UNO R3. It should work on any Arduino. 

The code currently supports the MCP23008, PCF8574 and PCF8574A I2C expanders

Select these with the following addresses

* 0x00 - 0x07 MCP23008 addresses 0x20-0x27. (This is backward compatible with an earlier library revision)
* 0x20 - 0x27 PCF8574
* 0x38 - 0x3F PCF8574A

Note that the MCP23008 and PCF8574 chips use the same i2c address range. Many LCD backpacks also use one of these chips. Be careful when mixing all this on the same bus to avoid duplicating addresses. To confuse things further, raw I2C addresses have the lowest order bit as a read/write signal, so some documents, like some of the PCF8574 datasheets, will refer to 0x40 and 0x70 which is 0x20 and 0x38 shifted left one bit.

You can also connect the ACE128 sensor directly to 8 Arduino pins, with an alternate constructor.

Usage
--------------------------------------------------------------------------------
See the ACE128test and ACE128testpins examples. 
* Include all the encoder maps you need (see below) to match the pin sequences
of your ACE units. 
* Declare all your ACE128 objects using the ACE128 constructor. It takes an I2C address and a pointer to the encoder map.
    An optional third integer can take a positive integer to show where to store zero info in eeprom. Allow for three bytes.
* call the begin method for each ACE128 object from setup(). This will use the eeprom settings or fall back to setting the current position as zero.
* The pos() and upos() methods return the position relative to a logical zero
position rather than the zero position returned by the encoder, which is in a
mechanically arbitrary spot. When it rolls over the turns are stored for use by mpos and saved in eeprom
* Once per loop(), call pos(), upos(), or mpos() and store the value in a variable. Accessing i2c bus takes some cycles, so don't call pos() everytime you want to
refer to it. 
* there are three setting functions
* setZero()   - set the current location to zero (does not update multiturn)
* setZero(int)   -  sets the zero point to the 0-127 number given
* setMpos(int)    - sets the current location as this multiturn value

Encoder Maps
--------------------------------------------------------------------------------

This library comes with various encoder maps to permit different wiring of the pins
between the ACE and the IO expander. These are generated by the included make_encodermap example sketch. To generate a custom encoder map:
* edit the make_encodermap sketch
* change the pinOrder array to match your wiring
* change the pinString to match your wiring
* load the sketch to the Arduino
* copy the serial monitor output to a new .h file in the ACE128 folder.  

12345678 is for the "rising counter clockwise" wiring, which matches the datasheet
numbers and is recommended for breadboard testing. 
When breadboarding, remember the pins on the sensor are numbered anticlockwise as viewed from above.

comments and feedback via https://github.com/arielnh56/ACE128

more details and videos at https://www.tindie.com/products/arielnh56/high-resolution-absolute-encoder-128-positions/

buy assembled units at https://www.tindie.com/products/arielnh56/digital-knob-for-arduino-i2c-absolute-encoder/

  [1]: https://github.com/arielnh56/ace128-rpi